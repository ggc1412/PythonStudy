import pandas as pd
import numpy as np
#dataframe 이차원 데이터  //엑셀 같은 것
#series // 1차원 데이터 / 굳이 생성할 일은 없고 파생된 결과로서 많이 씀 / index 설정 가능
#numpydml ndarray를 기반으로 indexing기능을 추가하여 1차원 배열을 나타냄

##Series 생성##
s1 = pd.Series(['a','b', 3]) #설정 안하면 0베이스 인덱스로 설정됨. #자동으로 데이터 타입을 인식해서 만듬
s2 = pd.Series(np.arange(200))

s3 = pd.Series([1,2,3],[100, 200, 'k']) #index 설정 가능 / numpy는 인덱스가 0베이스로 자동 생성, 설정 불가
s4 = pd.Series(np.arange(5), np.arange(100,105), dtype=np.int16) #메모리 최적화를 위해 타입 및 크기 지정용?
s4[104] = 6 #index로 접근하여 값 업데이트 가능
s4[200] = 1 #index가 없을 경우 값의 추가 가능
s4[[102, 103]] = [111, 222] #다중 값을 변경 가능
s4.drop(104) #index값으로 삭제된 Series 반환 / 원래 Series는 변동 없음
s4.drop(104, inplace=True) #복사본이 아니라 본 객체를 수정

s4[[100,102]] #index 리스트로 여러값을 가져올 수 있음
s4[400] = np.NaN
s5 = pd.Series(np.arange(6), s4.index)
s6 = pd.Series(s4.values, np.arange(6))
################################################################################
##Series 심플 분석##
len(s6) #7
s6.size #7
s6.shape #(7,)
s6.unique() #[0, 1, 2, 3, 6, nan] #중복값 제거
s6.count() #6 #NaN 값 제외 #pandas의 경우 기본적으로 nan값을 제외하고 연산을 한다.
s6.mean() #2.1666666666666665
s6.value_counts() #각값의 개수를 리턴함
s6.head() #상위 n개를 보여줌, 기본 5개
s6.tail(3) #하위 n개를 보여줌, 기본 5개
s6[[2,3,5]].value_counts()

a = np.array([2, 2, 2, 2, np.NaN])
a.mean() #nan
b = pd.Series(a)
b.mean() #2.0 #nan을 무시하고 값을 반환함
################################################################################
##Series 연산##
s7 = pd.Series([1, 2, 3, 4], ['a', 'b', 'c', 'd'])
s8 = pd.Series([6, 3, 2, 1], ['d', 'c', 'b', 'a'])
s7 + s8 #같은 index끼리 계산

s7 ** 2 #스칼라와의 연산은 각 원소별로 스칼라와의 연산이 적용
s7 ** s8 #Series와의 연산은 각 인덱스에 맞는 값끼리 연산이 적용
         #이때, 인덱스의 pair가 맞지 않으면 맞지 않는 인덱스 결과는 NaN
################################################################################
##Series Boolean Selection 활용##
s9 = pd.Series(np.arange(10), np.arange(10)+1)
s9>5 #Boolean 값을 반환함
s9[s9>5] #index가 True인 것만 반환함
s9.index>5 #index값을 기준으로도 처리 가능하다.
(s9>5) & (s9<8) #()를 묶어서 다중조건 설정도 가능하다.
(s9 > 7).sum()
s9[s9 > 7].sum()
################################################################################
##Series 슬라이싱##
s10 = pd.Series(np.arange(100, 105))
s10[1:3] #인덱스 1이상 3미만
s11 = pd.Series(np.arange(100, 105), ['a', 'c', 'b', 'd', 'e'])
s11[1:3] #문자열이 인덱스인 경우에도 숫자 인덱스로 찾아줌
s11['c':'e']
#c,b,d,e 인덱스 값 출력됨.
#문자 인덱스의 경우, 마지막 인덱스를 포함한다.
#마지막 인덱스의 다음 인덱스를 모르기 때문에 어찌보면 당연.
################################################################################
